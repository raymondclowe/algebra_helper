/**
 * Automated Question Validator for Algebra Helper
 * 
 * This tool validates all question types generated by the algebra_helper application
 * using Gemini 3 Pro via OpenRouter API.
 * 
 * Usage: npm run validate-questions
 */

const puppeteer = require('puppeteer');
const path = require('path');
const fs = require('fs').promises;
const config = require('./config');
const apiClient = require('./api-client');
const ScreenshotGenerator = require('./screenshot-generator');
const issueGenerator = require('./issue-generator');

class QuestionValidator {
    constructor() {
        this.screenshotGenerator = null;
        this.results = [];
        this.browser = null;
        this.page = null;
    }
    
    /**
     * Initialize the validator
     */
    async initialize() {
        console.log('üöÄ Initializing Question Validator...\n');
        
        // Validate configuration
        const configValidation = config.validate();
        if (!configValidation.valid) {
            console.error('‚ùå Configuration Error:');
            configValidation.errors.forEach(err => console.error(`   - ${err}`));
            process.exit(1);
        }
        
        console.log('‚úÖ Configuration validated');
        console.log(`   Model: ${config.modelName}`);
        console.log(`   Levels to test: ${config.levelsToTest.length}`);
        console.log(`   Questions per level: ${config.questionsPerLevel}\n`);
        
        // Ensure output directories exist
        await fs.mkdir(config.outputDir, { recursive: true });
        await fs.mkdir(config.issuesDir, { recursive: true });
        await fs.mkdir(config.screenshotsDir, { recursive: true });
        
        // Initialize screenshot generator
        this.screenshotGenerator = new ScreenshotGenerator();
        await this.screenshotGenerator.initialize();
        
        // Initialize browser for question generation
        this.browser = await puppeteer.launch({
            headless: 'new',
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        
        this.page = await this.browser.newPage();
        
        // Load the algebra helper HTML
        const algebraHelperPath = path.join(__dirname, '..', 'algebra-helper.html');
        await this.page.goto(`file://${algebraHelperPath}`, {
            waitUntil: 'networkidle0',
            timeout: 30000
        });
        
        // Wait for scripts to load
        await this.page.waitForFunction(
            () => window.Generator && window.MathJax && window.MathJax.typesetPromise,
            { timeout: 15000 }
        );
        
        console.log('‚úÖ Question generator initialized\n');
    }
    
    /**
     * Generate a question at a specific level
     */
    async generateQuestion(level) {
        const question = await this.page.evaluate((lvl) => {
            // Generate question using the app's generator
            const q = window.Generator.getQuestionForLevel(lvl);
            
            // Build options array from displayAnswer and distractors (similar to Learning.setupUI)
            const options = [
                q.displayAnswer,
                q.distractors[0],
                q.distractors[1],
                q.distractors[2]
            ];
            
            // Shuffle and track correct index
            const correctAnswer = q.displayAnswer;
            const shuffledOptions = options.sort(() => Math.random() - 0.5);
            const correctIndex = shuffledOptions.indexOf(correctAnswer);
            
            return {
                tex: q.tex,
                options: shuffledOptions,
                correctIndex: correctIndex,
                explanation: q.explanation || '',
                displayAnswer: q.displayAnswer,
                distractors: q.distractors
            };
        }, level);
        
        return question;
    }
    
    /**
     * Validate a single question
     */
    async validateQuestion(level, topic, questionNumber) {
        console.log(`üìù Validating Level ${level} (${topic}) - Question ${questionNumber}...`);
        
        try {
            // Generate question
            const question = await this.generateQuestion(level);
            
            // Prepare metadata
            const metadata = {
                level: level,
                topic: topic,
                questionText: question.tex,
                correctAnswer: question.options[question.correctIndex],
                allOptions: question.options,
                questionNumber: questionNumber
            };
            
            // Generate screenshot
            const screenshotFilename = `level-${level}-q${questionNumber}.png`;
            const screenshotPath = path.join(config.screenshotsDir, screenshotFilename);
            
            const base64Image = await this.screenshotGenerator.captureQuestionScreenshot(
                question,
                metadata,
                screenshotPath
            );
            
            console.log(`   üì∏ Screenshot saved: ${screenshotFilename}`);
            
            // Validate with Gemini 3 Pro
            console.log(`   ü§ñ Sending to Gemini 3 Pro for validation...`);
            const apiResponse = await apiClient.validateQuestion(base64Image, metadata);
            
            if (!apiResponse.success) {
                console.error(`   ‚ùå API Error: ${apiResponse.error}`);
                return {
                    success: false,
                    error: apiResponse.error,
                    metadata: metadata
                };
            }
            
            // Parse validation response
            const validation = apiClient.parseValidationResponse(apiResponse.validationText);
            
            // Debug: Log parsed result
            console.log(`   Debug: isValid=${validation.isValid}, hasIssues=${validation.hasIssues}, needsReview=${validation.needsReview}`);
            
            if (validation.isValid) {
                console.log(`   ‚úÖ Valid`);
            } else {
                console.log(`   ‚ö†Ô∏è Has Issues`);
            }
            
            // Log feedback snippet (first 150 chars)
            if (apiResponse.validationText && apiResponse.validationText.length > 0) {
                const feedbackSnippet = apiResponse.validationText.substring(0, 150);
                console.log(`   üìã Feedback: ${feedbackSnippet}${apiResponse.validationText.length > 150 ? '...' : ''}`);
            } else {
                console.log(`   ‚ö†Ô∏è Warning: Empty feedback received from API`);
            }
            
            // Save issue if needed
            let issueFile = null;
            if (validation.needsReview) {
                issueFile = await issueGenerator.saveIssue(validation, metadata, screenshotPath);
                console.log(`   üìÑ Issue file created: ${path.basename(issueFile)}`);
            }
            
            return {
                success: true,
                level: level,
                topic: topic,
                questionNumber: questionNumber,
                isValid: validation.isValid,
                hasIssues: validation.hasIssues,
                feedback: validation.feedback,
                issueFile: issueFile,
                screenshotPath: screenshotPath,
                metadata: metadata
            };
            
        } catch (error) {
            console.error(`   ‚ùå Error: ${error.message}`);
            return {
                success: false,
                error: error.message,
                level: level,
                topic: topic,
                questionNumber: questionNumber
            };
        }
    }
    
    /**
     * Validate all questions
     */
    async validateAll() {
        console.log('üéØ Starting validation of all question types...\n');
        console.log('=' .repeat(70));
        console.log('\n');
        
        for (const levelDef of config.levelsToTest) {
            console.log(`\n${'='.repeat(70)}`);
            console.log(`Level ${levelDef.level}: ${levelDef.name}`);
            console.log('='.repeat(70));
            
            for (let q = 1; q <= config.questionsPerLevel; q++) {
                const result = await this.validateQuestion(levelDef.level, levelDef.name, q);
                this.results.push(result);
                
                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
        
        console.log('\n' + '='.repeat(70));
        console.log('Validation Complete!');
        console.log('='.repeat(70) + '\n');
    }
    
    /**
     * Generate summary report
     */
    async generateReport() {
        console.log('\nüìä Generating Summary Report...\n');
        
        const successfulResults = this.results.filter(r => r.success);
        const validQuestions = successfulResults.filter(r => r.isValid);
        const invalidQuestions = successfulResults.filter(r => !r.isValid);
        const errors = this.results.filter(r => !r.success);
        
        console.log('Summary Statistics:');
        console.log(`   Total Questions: ${this.results.length}`);
        console.log(`   ‚úÖ Valid: ${validQuestions.length}`);
        console.log(`   ‚ö†Ô∏è  Has Issues: ${invalidQuestions.length}`);
        console.log(`   ‚ùå Errors: ${errors.length}`);
        console.log('');
        
        // Generate detailed report
        const summaryPath = await issueGenerator.generateSummaryReport(successfulResults);
        console.log(`üìÑ Summary report saved: ${summaryPath}\n`);
        
        if (invalidQuestions.length > 0) {
            console.log('‚ö†Ô∏è  Issues Found:');
            invalidQuestions.forEach(q => {
                console.log(`   - Level ${q.level} (${q.topic}): ${q.feedback.substring(0, 80)}...`);
            });
            console.log(`\nüìÇ Issue files saved to: ${config.issuesDir}/\n`);
        } else {
            console.log('‚úÖ All questions validated successfully!\n');
        }
    }
    
    /**
     * Cleanup resources
     */
    async cleanup() {
        console.log('üßπ Cleaning up...\n');
        
        if (this.screenshotGenerator) {
            await this.screenshotGenerator.close();
        }
        
        if (this.browser) {
            await this.browser.close();
        }
    }
    
    /**
     * Main entry point
     */
    async run() {
        try {
            await this.initialize();
            await this.validateAll();
            await this.generateReport();
        } catch (error) {
            console.error('\n‚ùå Fatal Error:', error.message);
            console.error(error.stack);
            process.exit(1);
        } finally {
            await this.cleanup();
        }
        
        console.log('‚ú® Validation complete!\n');
    }
}

// Run the validator if this script is executed directly
if (require.main === module) {
    const validator = new QuestionValidator();
    validator.run().catch(error => {
        console.error('Fatal error:', error);
        process.exit(1);
    });
}

module.exports = QuestionValidator;
