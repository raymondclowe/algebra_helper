/**
 * Issue generator for creating GitHub issue files from validation failures
 */
const fs = require('fs').promises;
const path = require('path');
const config = require('./config');

class IssueGenerator {
    constructor() {
        this.issuesDir = config.issuesDir;
    }
    
    /**
     * Generate GitHub issue content from validation failure
     * @param {object} validationResult - Result from validation
     * @param {object} questionMetadata - Question metadata
     * @param {string} screenshotPath - Path to screenshot
     * @returns {string} Issue content in markdown
     */
    generateIssueContent(validationResult, questionMetadata, screenshotPath) {
        const timestamp = new Date().toISOString();
        
        return `# Question Validation Issue - ${questionMetadata.topic} (Level ${questionMetadata.level})

**Generated by:** Automated Question Validator
**Date:** ${timestamp}
**Topic:** ${questionMetadata.topic}
**Difficulty Level:** ${questionMetadata.level}

## Issue Summary

The automated validation tool has identified an issue with a generated question.

## Question Details

**Question Text (LaTeX):**
\`\`\`latex
${questionMetadata.questionText}
\`\`\`

**Correct Answer:** ${questionMetadata.correctAnswer}

**All Options:**
${questionMetadata.allOptions.map((opt, idx) => `${idx + 1}. ${opt}`).join('\n')}

## Gemini 3 Pro Validation Feedback

${validationResult.feedback}

## Screenshot

Screenshot saved at: \`${screenshotPath}\`

## Recommended Actions

1. Review the question generation logic for Level ${questionMetadata.level} (${questionMetadata.topic})
2. Verify the mathematical correctness of the question
3. Check distractor generation logic
4. Update question templates if needed
5. Re-run validation after fixes

## Technical Details

- **Question Level:** ${questionMetadata.level}
- **Topic:** ${questionMetadata.topic}
- **Generator Function:** Level ${questionMetadata.level} question generator
- **Validation Model:** ${config.modelName}

---

*This issue was automatically generated by the question validation tool. Please review and fix the underlying generator code.*
`;
    }
    
    /**
     * Save issue to file
     * @param {object} validationResult - Validation result
     * @param {object} questionMetadata - Question metadata
     * @param {string} screenshotPath - Path to screenshot
     * @returns {Promise<string>} Path to saved issue file
     */
    async saveIssue(validationResult, questionMetadata, screenshotPath) {
        // Ensure issues directory exists
        await fs.mkdir(this.issuesDir, { recursive: true });
        
        // Generate filename
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const safeTopicName = questionMetadata.topic.replace(/[^a-zA-Z0-9]/g, '-');
        const filename = `issue-level-${questionMetadata.level}-${safeTopicName}-${timestamp}.md`;
        const filepath = path.join(this.issuesDir, filename);
        
        // Generate issue content
        const content = this.generateIssueContent(validationResult, questionMetadata, screenshotPath);
        
        // Save to file
        await fs.writeFile(filepath, content, 'utf-8');
        
        return filepath;
    }
    
    /**
     * Generate summary report of all issues
     * @param {Array} issues - Array of issue metadata
     * @returns {Promise<string>} Path to summary file
     */
    async generateSummaryReport(issues) {
        const timestamp = new Date().toISOString();
        const summary = `# Question Validation Summary Report

**Generated:** ${timestamp}
**Total Questions Validated:** ${issues.length}
**Issues Found:** ${issues.filter(i => !i.isValid).length}
**Valid Questions:** ${issues.filter(i => i.isValid).length}

## Issues by Level

${this.groupIssuesByLevel(issues)}

## Details

${issues.map((issue, idx) => `
### ${idx + 1}. Level ${issue.level} - ${issue.topic}

**Status:** ${issue.isValid ? '✅ Valid' : '❌ Has Issues'}
**Feedback:** ${issue.feedback.substring(0, 200)}${issue.feedback.length > 200 ? '...' : ''}
${issue.issueFile ? `**Issue File:** ${issue.issueFile}` : ''}

---
`).join('\n')}

## Recommendations

${this.generateRecommendations(issues)}

---

*Generated by Automated Question Validator using ${config.modelName}*
`;
        
        const summaryPath = path.join(config.outputDir, `validation-summary-${new Date().toISOString().replace(/[:.]/g, '-')}.md`);
        await fs.mkdir(config.outputDir, { recursive: true });
        await fs.writeFile(summaryPath, summary, 'utf-8');
        
        return summaryPath;
    }
    
    /**
     * Group issues by level for summary
     */
    groupIssuesByLevel(issues) {
        const byLevel = {};
        issues.forEach(issue => {
            if (!byLevel[issue.level]) {
                byLevel[issue.level] = { valid: 0, invalid: 0, topic: issue.topic };
            }
            if (issue.isValid) {
                byLevel[issue.level].valid++;
            } else {
                byLevel[issue.level].invalid++;
            }
        });
        
        return Object.keys(byLevel).sort((a, b) => Number(a) - Number(b)).map(level => {
            const data = byLevel[level];
            const total = data.valid + data.invalid;
            const status = data.invalid === 0 ? '✅' : '⚠️';
            return `- **Level ${level} (${data.topic})**: ${status} ${data.valid}/${total} valid`;
        }).join('\n');
    }
    
    /**
     * Generate recommendations based on issues found
     */
    generateRecommendations(issues) {
        const problemLevels = issues.filter(i => !i.isValid).map(i => i.level);
        
        if (problemLevels.length === 0) {
            return '✅ All questions validated successfully! No issues found.';
        }
        
        const uniqueLevels = [...new Set(problemLevels)].sort((a, b) => a - b);
        
        return `
⚠️ **${problemLevels.length} question(s) need attention**

**Priority Levels to Review:** ${uniqueLevels.join(', ')}

**Suggested Actions:**
1. Review the question generation code for the flagged levels
2. Check mathematical correctness of formulas and calculations
3. Verify distractor generation produces genuinely incorrect answers
4. Ensure question text is clear and unambiguous
5. Re-run validation after making fixes

**Next Steps:**
1. Open and review each generated issue file in \`${this.issuesDir}/\`
2. Fix the underlying problems in the question generator code
3. Run the validator again to verify fixes
`;
    }
}

module.exports = new IssueGenerator();
