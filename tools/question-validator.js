/**
 * Automated Question Validator for Algebra Helper
 * 
 * This tool validates all question types generated by the algebra_helper application
 * using Gemini 3 Pro via OpenRouter API.
 * 
 * It uses URL parameters (?testLevel=N&testType=M) to force specific questions
 * and captures screenshots from the actual live app for accurate MathJax rendering.
 * 
 * Usage: npm run validate-questions
 */

const path = require('path');
const fs = require('fs').promises;
const config = require('./config');
const apiClient = require('./api-client');
const ScreenshotGenerator = require('./screenshot-generator');
const issueGenerator = require('./issue-generator');

class QuestionValidator {
    constructor() {
        this.screenshotGenerator = null;
        this.results = [];
    }
    
    /**
     * Initialize the validator
     */
    async initialize() {
        console.log('ðŸš€ Initializing Question Validator...\n');
        
        // Validate configuration
        const configValidation = config.validate();
        if (!configValidation.valid) {
            console.error('âŒ Configuration Error:');
            configValidation.errors.forEach(err => console.error(`   - ${err}`));
            process.exit(1);
        }
        
        console.log('âœ… Configuration validated');
        console.log(`   Model: ${config.modelName}`);
        console.log(`   Levels to test: ${config.levelsToTest.length}`);
        
        // Calculate total question types to test
        const totalTypes = config.levelsToTest.reduce((sum, l) => sum + (l.questionTypes || 1), 0);
        console.log(`   Total question types to validate: ${totalTypes}\n`);
        
        // Ensure output directories exist
        await fs.mkdir(config.outputDir, { recursive: true });
        await fs.mkdir(config.issuesDir, { recursive: true });
        await fs.mkdir(config.screenshotsDir, { recursive: true });
        await fs.mkdir(config.responsesDir, { recursive: true });
        
        // Initialize screenshot generator (uses live app with URL parameters)
        this.screenshotGenerator = new ScreenshotGenerator();
        await this.screenshotGenerator.initialize();
        
        console.log('âœ… Screenshot generator initialized (using live app with URL parameters)\n');
    }
    
    /**
     * Save AI response for manual cross-checking
     * @param {string} filename - Base filename (without extension)
     * @param {object} responseData - Response data to save
     */
    async saveAIResponse(filename, responseData) {
        const responsePath = path.join(config.responsesDir, `${filename}.json`);
        await fs.writeFile(responsePath, JSON.stringify(responseData, null, 2));
        return responsePath;
    }
    
    /**
     * Validate a single question type within a level
     * @param {number} level - Difficulty level
     * @param {string} topic - Topic name
     * @param {number} questionType - Question type number (1-based)
     */
    async validateQuestionType(level, topic, questionType) {
        console.log(`ðŸ“ Validating Level ${level} (${topic}) - Type ${questionType}...`);
        
        try {
            // Generate screenshot using live app with URL parameters
            const screenshotFilename = `level-${level}-type${questionType}.png`;
            const screenshotPath = path.join(config.screenshotsDir, screenshotFilename);
            
            const { base64Image, questionData } = await this.screenshotGenerator.captureQuestionForLevel(
                level,
                questionType,
                screenshotPath
            );
            
            if (!questionData) {
                console.log(`   âš ï¸ No question data extracted`);
                return {
                    success: false,
                    error: 'No question data extracted',
                    level,
                    topic,
                    questionType
                };
            }
            
            console.log(`   ðŸ“¸ Screenshot saved: ${screenshotFilename}`);
            
            // Prepare metadata
            const metadata = {
                level: level,
                topic: topic,
                questionType: questionType,
                questionText: questionData.tex,
                instruction: questionData.instruction,
                correctAnswer: questionData.displayAnswer,
                distractors: questionData.distractors,
                allOptions: questionData.options,
                explanation: questionData.explanation
            };
            
            // Validate with Gemini 3 Pro
            console.log(`   ðŸ¤– Sending to Gemini 3 Pro for validation...`);
            const apiResponse = await apiClient.validateQuestion(base64Image, metadata);
            
            // Save AI response for manual cross-checking
            const responseFilename = `level-${level}-type${questionType}`;
            await this.saveAIResponse(responseFilename, {
                timestamp: new Date().toISOString(),
                level,
                topic,
                questionType,
                metadata,
                apiResponse: {
                    success: apiResponse.success,
                    validationText: apiResponse.validationText || null,
                    error: apiResponse.error || null
                }
            });
            console.log(`   ðŸ’¾ AI response saved for cross-checking`);
            
            if (!apiResponse.success) {
                console.error(`   âŒ API Error: ${apiResponse.error}`);
                return {
                    success: false,
                    error: apiResponse.error,
                    metadata: metadata
                };
            }
            
            // Parse validation response
            const validation = apiClient.parseValidationResponse(apiResponse.validationText);
            
            if (validation.isValid) {
                console.log(`   âœ… Valid`);
            } else {
                console.log(`   âš ï¸ Has Issues`);
            }
            
            // Log feedback snippet (first 150 chars)
            if (apiResponse.validationText && apiResponse.validationText.length > 0) {
                const feedbackSnippet = apiResponse.validationText.substring(0, 150);
                console.log(`   ðŸ“‹ Feedback: ${feedbackSnippet}${apiResponse.validationText.length > 150 ? '...' : ''}`);
            } else {
                console.log(`   âš ï¸ Warning: Empty feedback received from API`);
            }
            
            // Save issue if needed
            let issueFile = null;
            if (validation.needsReview) {
                issueFile = await issueGenerator.saveIssue(validation, metadata, screenshotPath);
                console.log(`   ðŸ“„ Issue file created: ${path.basename(issueFile)}`);
            }
            
            return {
                success: true,
                level: level,
                topic: topic,
                questionType: questionType,
                isValid: validation.isValid,
                hasIssues: validation.hasIssues,
                feedback: validation.feedback,
                issueFile: issueFile,
                screenshotPath: screenshotPath,
                metadata: metadata
            };
            
        } catch (error) {
            console.error(`   âŒ Error: ${error.message}`);
            return {
                success: false,
                error: error.message,
                level: level,
                topic: topic,
                questionType: questionType
            };
        }
    }
    
    /**
     * Validate all questions - tests each question type within each level
     */
    async validateAll() {
        console.log('ðŸŽ¯ Starting validation of all question types...\n');
        console.log('=' .repeat(70));
        
        // Calculate total
        const totalTypes = config.levelsToTest.reduce((sum, l) => sum + (l.questionTypes || 1), 0);
        let processed = 0;
        
        console.log(`\nðŸ“Š Testing ${totalTypes} question types across ${config.levelsToTest.length} levels\n`);
        
        for (const levelDef of config.levelsToTest) {
            console.log(`\n${'='.repeat(70)}`);
            console.log(`Level ${levelDef.level}: ${levelDef.name} (${levelDef.questionTypes || 1} question types)`);
            console.log('='.repeat(70));
            
            const numTypes = levelDef.questionTypes || 1;
            for (let qType = 1; qType <= numTypes; qType++) {
                const result = await this.validateQuestionType(levelDef.level, levelDef.name, qType);
                this.results.push(result);
                processed++;
                
                console.log(`   [Progress: ${processed}/${totalTypes}]`);
                
                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
        
        console.log('\n' + '='.repeat(70));
        console.log('Validation Complete!');
        console.log('='.repeat(70) + '\n');
    }
    
    /**
     * Generate summary report
     */
    async generateReport() {
        console.log('\nðŸ“Š Generating Summary Report...\n');
        
        const successfulResults = this.results.filter(r => r.success);
        const validQuestions = successfulResults.filter(r => r.isValid);
        const invalidQuestions = successfulResults.filter(r => !r.isValid);
        const errors = this.results.filter(r => !r.success);
        
        console.log('Summary Statistics:');
        console.log(`   Total Questions: ${this.results.length}`);
        console.log(`   âœ… Valid: ${validQuestions.length}`);
        console.log(`   âš ï¸  Has Issues: ${invalidQuestions.length}`);
        console.log(`   âŒ Errors: ${errors.length}`);
        console.log('');
        
        // Generate detailed report
        const summaryPath = await issueGenerator.generateSummaryReport(successfulResults);
        console.log(`ðŸ“„ Summary report saved: ${summaryPath}\n`);
        
        if (invalidQuestions.length > 0) {
            console.log('âš ï¸  Issues Found:');
            invalidQuestions.forEach(q => {
                console.log(`   - Level ${q.level} (${q.topic}): ${q.feedback.substring(0, 80)}...`);
            });
            console.log(`\nðŸ“‚ Issue files saved to: ${config.issuesDir}/\n`);
        } else {
            console.log('âœ… All questions validated successfully!\n');
        }
    }
    
    /**
     * Cleanup resources
     */
    async cleanup() {
        console.log('ðŸ§¹ Cleaning up...\n');
        
        if (this.screenshotGenerator) {
            await this.screenshotGenerator.close();
        }
    }
    
    /**
     * Main entry point
     */
    async run() {
        try {
            await this.initialize();
            await this.validateAll();
            await this.generateReport();
        } catch (error) {
            console.error('\nâŒ Fatal Error:', error.message);
            console.error(error.stack);
            process.exit(1);
        } finally {
            await this.cleanup();
        }
        
        console.log('âœ¨ Validation complete!\n');
    }
}

// Run the validator if this script is executed directly
if (require.main === module) {
    const validator = new QuestionValidator();
    validator.run().catch(error => {
        console.error('Fatal error:', error);
        process.exit(1);
    });
}

module.exports = QuestionValidator;
